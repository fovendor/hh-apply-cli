#!/usr/bin/env bash
set -euo pipefail

export LC_ALL="${LC_ALL:-C.UTF-8}"
export LANG="${LANG:-C.UTF-8}"

if [ -f "$HOME/.config/hhcli/config.sh" ]; then
    source "$HOME/.config/hhcli/config.sh"
fi

usage() {
  cat <<'EOF'
v.2.1.1
Использование: hhcli [опции]
  --prof-roles или -p   показать справочник профессиональных ролей
  --find-city           интерактивный поиск ID города для ручного режима
  --cover FILE          путь к файлу с сопроводительным письмом (перебивает COVER_FILE из настроек)
  --clear-cache         удалить кэшированные справочники API
  --help или -h         помощь
EOF
}

format_cell() {
  local text="$1"
  local width="$2"
  text="${text//$'\n'/ }"
  text="${text//$'\t'/ }"
  local len; len="$(printf '%s' "$text" | wc -m | tr -d '[:space:]')"
  local out="$text"
  if (( len > width )); then
    local cutw=$(( width - 1 ))
    out="$(printf '%s' "$text" | cut -c 1-"$cutw")…"
  fi
  local after_len; after_len="$(printf '%s' "$out" | wc -m | tr -d '[:space:]')"
  local pad=$(( width - after_len ))
  if (( pad > 0 )); then
    printf "%s%*s" "$out" "$pad" ""
  else
    printf "%s" "$out"
  fi
}

api_call() {
  local out
  if ! out="$(hh-applicant-tool call-api "$@")"; then
    echo "---" >&2
    echo "ОШИБКА: вызов API завершился неудачно (см. сообщение выше от hh-applicant-tool)." >&2
    return 1
  fi
  if ! jq -e . >/dev/null 2>&1 <<<"$out"; then
    echo "ОШИБКА: API вернул не-JSON для '$*'. Возможно, просрочена аутентификация." >&2
    echo "Попробуйте запустить: hhcli --auth" >&2
    return 1
  fi
  printf '%s' "$out"
}

show_prof_roles() {
  echo "Загрузка справочника профессиональных ролей" >&2
  local roles_json; roles_json="$(api_call /professional_roles)"
  {
    echo -e "ID\tНАЗВАНИЕ РОЛИ\t(КАТЕГОРИЯ)"
    printf -- "-%.0s" $(seq 1 "$(tput cols 2>/dev/null || echo 80)")
    echo ""
    jq -r '.categories[] | .name as $cat_name | .roles[] | "\(.id)\t\(.name)\t(\($cat_name))"' <<< "$roles_json" |
      column -t -s $'\t'
  } | less -S -R
  exit 0
}

ensure_dictionaries_cache() {
    local cache_file="$CACHE_DIR/dictionaries.json"
    if [[ ! -f "$cache_file" ]]; then
        echo "Кэширую общие справочники" >&2
        if ! api_call "/dictionaries" > "$cache_file"; then
            rm -f "$cache_file"
            echo "ОШИБКА: Не удалось загрузить справочники." >&2
            exit 1
        fi
    fi
    cat "$cache_file"
}

ensure_areas_cache() {
    local cache_file_flat="$CACHE_DIR/areas_for_fzf.txt"
    if [[ ! -f "$cache_file_flat" ]]; then
        local cache_file_json="$CACHE_DIR/areas.json"
        echo "Кэширую справочник городов (это займет некоторое время)" >&2
        if ! api_call "/areas" > "$cache_file_json"; then
            rm -f "$cache_file_json"
            echo "ОШИБКА: Не удалось загрузить справочник городов." >&2
            exit 1
        fi
        echo "Обрабатываю справочник" >&2
        jq -r '
          .[] | .areas[] as $level1 |
          (
            if ($level1.areas | length == 0) then
              "\($level1.id)\t\($level1.name)"
            else
              $level1.areas[] as $level2 |
              (
                if ($level2.areas | length == 0) then
                  "\($level2.id)\t\($level2.name) (\($level1.name))"
                else
                  $level2.areas[] | "\(.id)\t\(.name) (\($level2.name))"
                end
              )
            end
          )
        ' "$cache_file_json" > "$cache_file_flat"
    fi
}

find_city_interactive() {
    ensure_areas_cache
    echo "Поиск по городам. Выберите нужный и нажмите Enter." >&2
    echo "Результат (ID и название) будет выведен в консоль." >&2
    fzf < "$CACHE_DIR/areas_for_fzf.txt"
    exit 0
}

CACHE_DIR="$HOME/.cache/hhcli-cache"

while [[ $# -gt 0 ]]; do
  case "$1" in
--auth) hh-applicant-tool authorize; exit 0;;
--list-resumes) hh-applicant-tool list-resumes; exit 0;;
proxy) shift; hh-applicant-tool "$@"; exit 0;;
    -p|--prof-roles) show_prof_roles; exit 0;;
    --cover) COVER_FILE="$2"; shift 2;;
    --clear-cache) rm -rf "$CACHE_DIR"; echo "Кэш очищен."; exit 0;;
    --find-city) find_city_interactive; exit 0;;
    -h|--help) usage; exit 0;;
    *) echo "Неизвестный аргумент: $1"; usage; exit 1;;
  esac
done

if ! command -v fzf &> /dev/null; then echo "ОШИБКА: 'fzf' не найден." >&2; exit 12; fi
if ! command -v w3m &> /dev/null; then echo "ОШИБКА: 'w3m' не найден." >&2; exit 13; fi

mkdir -p "$CACHE_DIR"

echo
MY_RESUMES_JSON="$(api_call /resumes/mine)"
RESUME_COUNT=$(jq '.items | length' <<< "$MY_RESUMES_JSON")
SELECTED_RESUME_JSON=""

if [[ "$RESUME_COUNT" -eq 0 ]]; then
    echo "ОШИБКА: У вас нет ни одного резюме." >&2; exit 1
elif [[ "$RESUME_COUNT" -eq 1 ]]; then
    SELECTED_RESUME_JSON=$(jq '.items[0]' <<< "$MY_RESUMES_JSON")
    RESUME_TITLE=$(jq -r '.title' <<< "$SELECTED_RESUME_JSON")
    echo "Найдено одно резюме: «$RESUME_TITLE»"
    echo
else
    echo -e "\e[1mНайдено несколько резюме. Выберите одно из них:\e[0m"
    echo
    jq -r '.items | to_entries[] | "  \(.key+1)) \(.value.title)"' <<< "$MY_RESUMES_JSON"
    echo
    IFS= read -r -p "> " idx </dev/tty
    idx=$((idx-1))
    SELECTED_RESUME_JSON=$(jq ".items[$idx]" <<< "$MY_RESUMES_JSON")
    if [[ "$SELECTED_RESUME_JSON" == "null" ]]; then
        echo "Неверный выбор." >&2; exit 1
    fi
fi
SELECTED_RESUME_ID=$(jq -r '.id' <<< "$SELECTED_RESUME_JSON")

echo -e "\e[1mВыберите способ поиска вакансий:\e[0m"
echo "  1) Автоматический (рекомендации hh.ru)"
echo "  2) Ручной (поиск по ключевым словам)"
echo
IFS= read -r -p "> " SEARCH_MODE_CHOICE </dev/tty
SEARCH_MODE_CHOICE=${SEARCH_MODE_CHOICE:-1}

SUMMARY_STRING=""
VACANCIES_JSON_RAW=""

if [[ "$SEARCH_MODE_CHOICE" -eq 1 ]]; then
    RESUME_TITLE=$(jq -r '.title' <<< "$SELECTED_RESUME_JSON")
    SUMMARY_STRING="Рекомендованные вакансии для резюме «$RESUME_TITLE»"

    DICTIONARIES=$(ensure_dictionaries_cache)
    filter_work_format_id=""
    filter_area_id=""
    filter_area_name=""
    filter_salary=""

    echo; echo -e "\e[1mВыберите формат:\e[0m"
    mapfile -t WORK_FORMAT_OPTS < <(jq -r '.work_format[] | "\(.id)\t\(.name)"' <<< "$DICTIONARIES")
    echo "  0) Любой"
    for i in "${!WORK_FORMAT_OPTS[@]}"; do
        name=$(cut -f2 <<< "${WORK_FORMAT_OPTS[$i]}")
        echo "  $((i+1))) $name"
    done
    echo; IFS= read -r -p "> " WORK_FORMAT_CHOICE </dev/tty
    WORK_FORMAT_CHOICE=${WORK_FORMAT_CHOICE:-0}
    if [[ "$WORK_FORMAT_CHOICE" -ne 0 ]]; then
        filter_work_format_id=$(cut -f1 <<< "${WORK_FORMAT_OPTS[$((WORK_FORMAT_CHOICE-1))]}")
        format_name=$(cut -f2 <<< "${WORK_FORMAT_OPTS[$((WORK_FORMAT_CHOICE-1))]}")
        SUMMARY_STRING+=", формат: ${format_name,,}"
    fi

    if [[ "${filter_work_format_id:-}" != "REMOTE" ]]; then
        echo; echo -e "\e[1mВыберите город:\e[0m"
        RESUME_DATA_JSON=$(api_call "/resumes/$SELECTED_RESUME_ID")
        DEFAULT_AREA_ID=$(jq -r '.area.id // empty' <<< "$RESUME_DATA_JSON")
        DEFAULT_AREA_NAME=$(jq -r '.area.name // empty' <<< "$RESUME_DATA_JSON")
        if [[ -n "$DEFAULT_AREA_ID" && "$DEFAULT_AREA_NAME" != "null" ]]; then
            echo "  1) В городе из резюме: «$DEFAULT_AREA_NAME»"
            echo "  2) Выбрать другой город"
            echo "  0) Везде (пропустить)"
            echo
            IFS= read -r -p "> " AREA_CHOICE </dev/tty
            AREA_CHOICE=${AREA_CHOICE:-1}
        else
            AREA_CHOICE=2
        fi

        if [[ "$AREA_CHOICE" -eq 1 ]]; then
            filter_area_id="$DEFAULT_AREA_ID"; filter_area_name="$DEFAULT_AREA_NAME"
        elif [[ "$AREA_CHOICE" -eq 2 ]]; then
            ensure_areas_cache
            selected_area="$(fzf < "$CACHE_DIR/areas_for_fzf.txt")" || true
            if [[ -n "$selected_area" ]]; then
                filter_area_id="$(cut -f1 <<< "$selected_area")"
                filter_area_name="$(cut -f2 <<< "$selected_area")"
            fi
        fi
    fi
    [[ -n "$filter_area_name" ]] && SUMMARY_STRING+=", регион: $filter_area_name"

    echo; echo -e "\e[1mЖелаемый уровень ЗП (Enter для пропуска)\e[0m"
    echo; IFS= read -r -p "> " filter_salary </dev/tty
    [[ -n "$filter_salary" ]] && SUMMARY_STRING+=", з/п от $filter_salary рублей"
    
    clear
    final_summary="${SUMMARY_STRING}."
    summary_length=$(printf "%s" "$final_summary" | wc -m)
    separator_line=$(printf "%${summary_length}s" | tr ' ' '-')
    echo "$separator_line"; echo "$final_summary"; echo "$separator_line"; echo
    
    echo "Получение рекомендованных вакансий" >&2
    VACANCIES_JSON_RAW=$(api_call "/resumes/$SELECTED_RESUME_ID/similar_vacancies" | jq '.items')

    echo "Пост-фильтрация полученных данных" >&2
    if [[ -n "$filter_work_format_id" ]]; then
        VACANCIES_JSON_RAW=$(jq --arg wf "$filter_work_format_id" '[.[] | select(any(.work_format[]; .id == $wf))]' <<< "$VACANCIES_JSON_RAW")
    fi
    if [[ -n "$filter_area_id" ]]; then
        VACANCIES_JSON_RAW=$(jq --arg area "$filter_area_id" '[.[] | select(.area.id == $area)]' <<< "$VACANCIES_JSON_RAW")
    fi
    if [[ -n "$filter_salary" ]]; then
        VACANCIES_JSON_RAW=$(jq --arg s "$filter_salary" '[.[] | select(.salary and .salary.from and (.salary.from >= ($s | tonumber)))]' <<< "$VACANCIES_JSON_RAW")
    fi
else
    SUMMARY_STRING="Ручной поиск по настройкам из файла"
    echo; echo "Выбран ручной режим. Использую настройки из файла"
    
    clear
    final_summary="${SUMMARY_STRING}."
    summary_length=$(printf "%s" "$final_summary" | wc -m)
    separator_line=$(printf "%${summary_length}s" | tr ' ' '-')
    echo "$separator_line"; echo "$final_summary"; echo "$separator_line"; echo
    
    declare -a VAC_ARGS=()
    TEXT_QUERY="$TEXT_INCLUDE"
    [[ -n "${NEGATIVE:-}" ]] && TEXT_QUERY="$TEXT_QUERY NOT ($NEGATIVE)"
    VAC_ARGS=( work_format="$WORK_FORMAT" text="$TEXT_QUERY" )
    [[ -n "$AREA_ID" ]] && VAC_ARGS+=( area="$AREA_ID" )
    [[ -n "${SEARCH_FIELD:-}" ]] && VAC_ARGS+=( search_field="$SEARCH_FIELD" )
    VAC_ARGS+=( period="$PERIOD" order_by=publication_time per_page=100 )
    CLEANED_IDS_CONFIG="${ROLE_IDS_CONFIG//[[:space:]]/}"
    if [[ -n "$CLEANED_IDS_CONFIG" ]]; then
      IFS=',' read -r -a ROLE_IDS <<< "$CLEANED_IDS_CONFIG"
      for rid in "${ROLE_IDS[@]}"; do VAC_ARGS+=( professional_role="$rid" ); done
    fi
    
    collect_vacancies() {
      local pages; pages="$(api_call /vacancies "${VAC_ARGS[@]}" | jq -r '.pages // 1')"
      [[ "$pages" -gt 10 ]] && pages=10
      for p in $(seq 0 $((pages-1))); do
        api_call /vacancies "${VAC_ARGS[@]}" page="$p"; sleep 0.5;
      done | jq -s '[ .[] | .items[] ]'
    }
    
    echo "Поиск вакансий" >&2
    VACANCIES_JSON_RAW="$(collect_vacancies)"
fi

echo "Загрузка полной истории откликов..." >&2

PAGES="$(api_call /negotiations status=all per_page=100 | jq -r '.pages // 0')"

APPLIED_HISTORY_JSON="$(
  if [[ "$PAGES" -gt 0 ]]; then
    for p in $(seq 0 $((PAGES-1))); do
      api_call /negotiations status=all per_page=100 page="$p"; sleep 0.2;
    done
  fi | jq -s '
    def norm: (tostring | ascii_downcase | gsub("[\r\n\t]+";" ") | gsub("[ ]+";" ") | gsub("^ | $";""));
    [ .[] | .items[]? | select(.vacancy.id != null) ] | {
        ids: [ .[].vacancy.id | tostring ],
        keys: [ .[] | ((.vacancy.name // "" | norm) + "|" + (.vacancy.employer.name // "" | norm)) ],
        emp_ids: [ .[].vacancy.employer.id | tostring ]
    } | {
        ids: (.ids | unique),
        keys: (.keys | unique),
        emp_ids: (.emp_ids | unique)
    }
  '
)"

echo "История откликов загружена." >&2

if [[ "${DEDUPE:-1}" -eq 1 ]]; then
    PROCESSED_JSON=$(jq '
      def norm: (tostring | ascii_downcase | gsub("[\r\n\t]+";" ") | gsub("[ ]+";" ") | gsub("^ | $";""));
      reduce .[] as $v ({seen:{}, unique: [], duplicates: []};
        (
          ($v.name // "" | norm) as $n |
          # УЛУЧШЕННАЯ ЛОГИКА: Явно проверяем, что .employer существует, перед тем как лезть в .id
          (if $v.employer and $v.employer.id then ($v.employer.id | tostring) else ($v.employer.name // "") end | norm) as $e |
          ($n + "|" + $e) as $k |
          if .seen[$k] then .duplicates += [$v] else .seen[$k]=true | .unique += [$v] end
        )
      )
    ' <<< "$VACANCIES_JSON_RAW")

    VACANCIES_JSON=$(jq '.unique' <<< "$PROCESSED_JSON")
    DUPLICATES_JSON=$(jq '.duplicates' <<< "$PROCESSED_JSON")
    DUPLICATES_COUNT=$(jq 'length' <<< "$DUPLICATES_JSON")
    if [[ "$DUPLICATES_COUNT" -gt 0 ]]; then
        echo "Удалено дублей по сочетанию "название+компания": $DUPLICATES_COUNT шт." >&2
        echo >&2
        echo "--- Список удаленных дублей ---" >&2
        {
          echo -e "Название вакансии\tКомпания\tСсылка"
          jq -r '.[] | [.name, .employer.name // "Имя не указано", .alternate_url] | @tsv' <<< "$DUPLICATES_JSON"
        } | column -t -s $'\t' >&2
        echo "------------------------------" >&2
    fi
else
    VACANCIES_JSON="$VACANCIES_JSON_RAW"
fi

if [[ "$(jq 'length' <<< "$VACANCIES_JSON")" -eq 0 ]]; then
    echo "По вашему запросу ничего не найдено. Попробуйте изменить фильтры."
    exit 0
fi

ALL_ENTRIES="$( jq --argjson history "$APPLIED_HISTORY_JSON" -c '
  def norm: (tostring | ascii_downcase | gsub("[\r\n\t]+";" ") | gsub("[ ]+";" ") | gsub("^ | $";""));
  to_entries | map(
    . as $e |
    ($e.value.id | tostring) as $vac_id |
    (($e.value.name // "" | norm) + "|" + ($e.value.employer.name // "" | norm)) as $vac_key |
    {
      idx: ($e.key+1),
      id: $vac_id,
      emp: ($e.value.employer.id | tostring),
      name: $e.value.name,
      employer_name: ($e.value.employer.name // "-"),
      url: $e.value.alternate_url,
      prev: ( ($history.emp_ids | index(($e.value.employer.id|tostring))) != null ),
      applied_by_id: ( ($history.ids | index($vac_id)) != null ),
      applied_by_key: ( ($history.keys | index($vac_key)) != null )
    }
  )
' <<< "$VACANCIES_JSON" )"

render_preview() {
    local full_line="$1"
    local preview_width="$2"
    local cache_dir_arg="$3"
    local vac_id; vac_id=$(echo "$full_line" | cut -f1)
    local cache_file="$cache_dir_arg/$vac_id.json"
    if [[ ! -f "$cache_file" ]]; then
        if ! api_call "/vacancies/$vac_id" > "$cache_file"; then
            rm -f "$cache_file"
            echo "ОШИБКА: Не удалось загрузить детали для $vac_id"
            return
        fi
    fi
    local vacancy_json; vacancy_json="$(cat "$cache_file")"
    if ! jq -e . >/dev/null 2>&1 <<<"$vacancy_json"; then
        echo "ОШИБКА: Кэш для вакансии $vac_id поврежден (невалидный JSON)."
        echo "Удаляю кэш-файл. Попробуйте просмотреть эту вакансию еще раз."
        rm -f "$cache_file"
        return
    fi
    
    echo "$vacancy_json" | jq -r '
    "Ссылка: \(.alternate_url)\n\n--- \(.name) ---\n\nРаботодатель: \(.employer.name)\n" +
    (if .area and .area.name then "Город: \(.area.name)\n" else "" end) +
    (if .salary then "Зарплата: \(.salary|if .from and .to then "\((.from|tostring))-\((.to|tostring)) \(.currency)" elif .from then "от \((.from|tostring)) \(.currency)" elif .to then "до \((.to|tostring)) \(.currency)" else "не указана" end)\n" else "" end) +
    "---"'
    
    echo "$vacancy_json" |
    jq -r '.description // "[ Описание для этой вакансии недоступно через API ]"' |
    w3m -cols "$preview_width" -T text/html -dump

    echo "$vacancy_json" | jq -r '
      if .key_skills and (.key_skills | length > 0) then
        "\n\n--- Ключевые навыки ---\n" + (.key_skills | map(.name) | join(", "))
      else
        ""
      end'
      
    echo "$vacancy_json" | jq -r '
      if .contacts then
        "\n\n--- Контакты ---\n" +
        (if .contacts.name and .contacts.name != "null" then "Контактное лицо: \(.contacts.name)\n" else "" end) +
        (if .contacts.email then "Email: \(.contacts.email)\n" else "" end) +
        (if .contacts.phones and (.contacts.phones | length > 0) then
          ( .contacts.phones[] | "Телефон: \(.formatted)\n" )
        else "" end)
      else
        ""
      end'
}

export -f render_preview
export -f api_call
export CACHE_DIR

FZF_MASTER_LIST=$(mktemp)
FZF_TOGGLE_STATE=$(mktemp)
trap 'rm -f "$FZF_MASTER_LIST" "$FZF_TOGGLE_STATE"' EXIT
echo "0" > "$FZF_TOGGLE_STATE"

jq -r '.[] | [ .id, .url, .name, .employer_name, .prev, .idx, .applied_by_id, .applied_by_key ] | @tsv' <<< "$ALL_ENTRIES" |
while IFS=$'\t' read -r id url name employer_name prev idx applied_by_id applied_by_key; do
  prev_applied_human=$([[ "$prev" == "true" ]] && echo "да" || echo "нет")
  COL_ID="$(format_cell "#$idx" "$MAX_ID")"
  COL_TITLE="$(format_cell "$name" "$MAX_TITLE")"
  COL_COMPANY="$(format_cell "$employer_name" "$MAX_COMPANY")"
  COL_STATUS="$(format_cell "$prev_applied_human" "$MAX_STATUS")"
  DISPLAY_LINE=$(printf "%s %s %s %s" "$COL_ID" "$COL_TITLE" "$COL_COMPANY" "$COL_STATUS")

  should_strike=0
  if [[ "${STRIKETHROUGH_APPLIED_VAC:-0}" -eq 1 && "$applied_by_id" == "true" ]]; then
      should_strike=1
  fi
  if [[ "${STRIKETHROUGH_APPLIED_VAC_NAME:-0}" -eq 1 && "$applied_by_key" == "true" ]]; then
      should_strike=1
  fi
  if [[ "$should_strike" -eq 1 ]]; then
      DISPLAY_LINE=$'\e[9m'"$DISPLAY_LINE"$'\e[0m'
  fi

  printf "%s\t%s\t%s\n" "$id" "$url" "$DISPLAY_LINE" >> "$FZF_MASTER_LIST"
done

HEADER=$(printf "%s %s %s %s" "$(format_cell "№" "$MAX_ID")" "$(format_cell "Название вакансии" "$MAX_TITLE")" "$(format_cell "Компания" "$MAX_COMPANY")" "$(format_cell "Ранее" "$MAX_STATUS")")
SEPARATOR="$(printf "%.0s-" $(seq 1 200))"
flip_fzf_state() { local current_state; current_state=$(cat "$FZF_TOGGLE_STATE"); local new_state=$(( (current_state + 1) % 2 )); echo "$new_state" > "$FZF_TOGGLE_STATE"; }
render_fzf_list() { local current_state; current_state=$(cat "$FZF_TOGGLE_STATE"); printf " \t \t%s\n" "$HEADER"; printf " \t \t%s\n" "$SEPARATOR"; if [[ "$current_state" -eq 1 ]]; then grep -v 'да *$' "$FZF_MASTER_LIST"; else cat "$FZF_MASTER_LIST"; fi; }
export -f flip_fzf_state; export -f render_fzf_list
export FZF_MASTER_LIST FZF_TOGGLE_STATE HEADER SEPARATOR
FZF_PROMPT="[Tab] выбрать, [Enter] подтвердить | [Ctrl-H] скрыть компании, куда был отклик > "
FZF_COLOR_OPTS=""
if [[ -n "${COLOR_BG:-}" ]]; then
    FZF_COLOR_OPTS="--color=bg:${COLOR_BG},bg+:${COLOR_BG_PLUS},fg:${COLOR_FG},fg+:${COLOR_FG_PLUS},hl:${COLOR_HL},border:${COLOR_BORDER},prompt:${COLOR_PROMPT},header:${COLOR_HEADER},info:${COLOR_INFO},marker:${COLOR_MARKER}"
fi

mapfile -t SELECTED_LINES < <(
  fzf --multi --ansi \
    $FZF_COLOR_OPTS \
    --marker='  ' \
    --pointer='$' \
    --layout=reverse-list \
    --header-lines=2 \
    --prompt="$FZF_PROMPT" \
    --preview-window="right:${PREVIEW_WIDTH_PERCENT}%:wrap" \
    --preview='render_preview {} {pw} "'"$CACHE_DIR"'"' \
    --delimiter=$'\t' --with-nth=3.. \
    --bind "ctrl-h:execute(flip_fzf_state)+reload(render_fzf_list),scroll-up:up,scroll-down:down" \
    < <(render_fzf_list)
) || true
mapfile -t SELECTED_IDS < <( for line in "${SELECTED_LINES[@]}"; do cut -f1 <<< "$line"; done )

if [[ ${#SELECTED_IDS[@]} -eq 0 ]]; then echo "Вакансии не выбраны. Завершение работы."; exit 0; fi

VAC_COUNT=${#SELECTED_IDS[@]}
RESUME_TITLE_FOR_PROMPT=$(jq -r .title <<< "$SELECTED_RESUME_JSON")
echo; echo "Вы выбрали ${VAC_COUNT} вакансий."

while true; do
    CONFIRM_CODE=$(( RANDOM % 90000 + 10000 ))
    echo -n "Для подтверждения отправки откликов на резюме «${RESUME_TITLE_FOR_PROMPT}», введите число ${CONFIRM_CODE}: "
    IFS= read -r USER_CONFIRM </dev/tty || true

    if [[ "$USER_CONFIRM" == "$CONFIRM_CODE" ]]; then
        echo "Подтверждение принято."
        break
    else
        echo
        echo "Ввод не совпал. Пожалуйста, попробуйте еще раз."
    fi
done

RESUME_ID="$SELECTED_RESUME_ID"
RESUME_TITLE=$(jq -r .title <<< "$SELECTED_RESUME_JSON")
echo "Отклик с резюме: «${RESUME_TITLE}»"

csv_escape() { local s="${1//$'\n'/ }"; s="${s//$'\t'/ }"; s="${s//\"/\"\"}"; printf '"%s"' "$s"; }
get_cfg_path() { local p; p="$(hh-applicant-tool config -p 2>/dev/null || true)"; if jq -e . >/dev/null 2>&1 <<<"$p"; then jq -r '.path // empty' <<<"$p"; elif [[ -n "$p" && -f "$p" ]]; then echo "$p"; elif [[ -f "$HOME/.config/hh-applicant-tool/config.json" ]]; then echo "$HOME/.config/hh-applicant-tool/config.json"; elif [[ -f "$HOME/Library/Application Support/hh-applicant-tool/config.json" ]]; then echo "$HOME/Library/Application Support/hh-applicant-tool/config.json"; else echo ""; fi; }

COVER_TEXT=""
CFG_PATH="$(get_cfg_path)"
if [[ -n "$COVER_FILE" && -f "$COVER_FILE" ]]; then COVER_TEXT="$(cat "$COVER_FILE")";
elif [[ -n "$CFG_PATH" && -f "$CFG_PATH" ]]; then COVER_TEXT="$(jq -r '.reply_message // empty' "$CFG_PATH" 2>/dev/null || true)"; fi

REPORT_DIR="$HOME/hh-reports/$(date +'%Y-%m-%d')"; mkdir -p "$REPORT_DIR"
REPORT_FILE="$REPORT_DIR/$(date +'%H-%M-%S')_apply.csv"
echo "$(csv_escape "Резюме: $RESUME_TITLE"),,,,,,, " > "$REPORT_FILE"
echo ",№,Вакансия,Компания,Ссылка,Откликался ранее,Отклик отправлен,Причина,Дата/время (MSK)" >> "$REPORT_FILE"

ACCESS_TOKEN=""
USER_AGENT="hh-applicant-tool bash-client"
if [[ -n "$CFG_PATH" && -f "$CFG_PATH" ]]; then
  ACCESS_TOKEN="$(jq -r '.token.access_token // empty' "$CFG_PATH" 2>/dev/null || true)"
  UA_FROM_CFG="$(jq -r '.user_agent // empty' "$CFG_PATH" 2>/dev/null || true)"
  [[ -n "$UA_FROM_CFG" && "$UA_FROM_CFG" != "null" ]] && USER_AGENT="$UA_FROM_CFG"
fi
if [[ -z "$ACCESS_TOKEN" || "$ACCESS_TOKEN" == "null" ]]; then echo "Не найден access_token. Запусти: hhcli --auth" >&2; exit 4; fi

http_post_negotiation() {
  local vacancy_id="$1"; local tmp_body; tmp_body="$(mktemp)"; local code;
  local curl_args=(-sS -o "$tmp_body" -w "%{http_code}" -X POST "https://api.hh.ru/negotiations" -H "Authorization: Bearer $ACCESS_TOKEN" -H "Accept: application/json" -H "HH-User-Agent: $USER_AGENT" --data-urlencode "vacancy_id=$vacancy_id" --data-urlencode "resume_id=$RESUME_ID")
  [[ -n "$COVER_TEXT" ]] && curl_args+=( --data-urlencode "message=$COVER_TEXT" )
  set +e; code="$(curl "${curl_args[@]}")"; local rc=$?; set -e
  echo "$rc" "$code" "$tmp_body"
}
is_complex_vacancy() {
  local vac_id="$1"
  local cache_file="$CACHE_DIR/$vac_id.json"
  if [[ ! -f "$cache_file" ]]; then if ! api_call "/vacancies/$vac_id" > "$cache_file"; then rm -f "$cache_file"; return 1; fi; fi
  jq -e '. | has("questions") and (.questions | length > 0)' "$cache_file" >/dev/null 2>&1
}

SELECTED_ENTRIES_JSON=$(jq --argjson ids "$(printf '%s\n' "${SELECTED_IDS[@]}" | jq -R . | jq -s .)" 'map(select(.id as $id | $ids | index($id)))' <<< "$ALL_ENTRIES")

echo
echo "Статус откликов:"
echo
any_sent=0

while IFS= read -r row; do
  [[ -z "$row" ]] && continue
  idx="$(jq -r '.idx' <<< "$row")"; id="$(jq -r '.id' <<< "$row")"; name="$(jq -r '.name' <<< "$row")"
  employer_name="$(jq -r '.employer_name' <<< "$row")"; url="$(jq -r '.url' <<< "$row")"; prev_applied="$(jq -r '.prev' <<< "$row")"
  prev_applied_human=$([[ "$prev_applied" == "true" ]] && echo "да" || echo "нет")
  
  sent="нет" 
  reason=""

  status_message=""
  action_prefix=""
  reason_text=""

  if [[ $SKIP_APPLIED -eq 1 && "$prev_applied" == "true" ]]; then
    action_prefix="Пропуск"
    reason_text="(ранее был отклик в эту компанию)"
    reason="skip-applied"
  elif is_complex_vacancy "$id"; then
    action_prefix="Пропуск"
    reason_text="(требуются ответы на сайте)"
    reason="questions_required (precheck)"
  else
    read -r rc http_code bodyfile <<<"$(http_post_negotiation "$id")"
    if (( rc != 0 )); then
      action_prefix="Отклик НЕ доставлен"
      reason_text="(сетевая ошибка)"
      reason="curl rc=$rc"
    else
      if [[ "$http_code" =~ ^[123][0-9]{2}$ ]]; then 
        status_message="ОК"
        sent="да"
        reason=""
        any_sent=1
      else
        if jq -e . >/dev/null 2>&1 <"$bodyfile"; then
          kinds="$(jq -r '.errors[]? | .type' <"$bodyfile" | tr '\n' ' ')"
          msg="$(jq -r '.errors[]? | (.reason // .value // .message // "")' <"$bodyfile" | paste -sd'|' -)"
          
          case " $kinds " in
            *" questions_required "*)
              action_prefix="Пропуск"
              reason_text="(требуются ответы)"
              reason="${msg:-questions_required}"
              ;;
            *" already_applied "*)
              action_prefix="Пропуск"
              reason_text="(ранее был отклик в эту компанию)"
              reason="${msg:-already_applied}"
              ;;
            *" negotiations_forbidden "*)
              action_prefix="Отклик НЕ доставлен"
              reason_text="(работодатель запретил отклики)"
              reason="${msg:-negotiations_forbidden}"
              ;;
            *" resume_not_published "*)
              action_prefix="Отклик НЕ доставлен"
              reason_text="(резюме не опубликовано)"
              reason="${msg:-resume_not_published}"
              ;;
            *" conditions_not_met "*)
              action_prefix="Отклик НЕ доставлен"
              reason_text="(не выполнены условия)"
              reason="${msg:-conditions_not_met}"
              ;;
            *" not_found "*)
              action_prefix="Отклик НЕ доставлен"
              reason_text="(вакансия в архиве)"
              reason="${msg:-not_found}"
              ;;
            *)
              if [[ "$msg" == "test_required" ]]; then
                  action_prefix="Пропуск"
                  reason_text="(требуются ответы)"
                  reason="test_required"
              else
                  action_prefix="Отклик НЕ доставлен"
                  reason_text="(ошибка API: ${msg:-unknown})"
                  reason="${msg:-unknown}"
              fi
              ;;
          esac
        else
          action_prefix="Отклик НЕ доставлен"
          reason_text="(не-JSON ответ, HTTP $http_code)"
          reason="HTTP $http_code (не-JSON)"
        fi
      fi
      [[ -f "${bodyfile:-}" ]] && rm -f "$bodyfile" || true
    fi
  fi
  
  if [[ -z "$status_message" ]]; then
      status_message="$action_prefix $reason_text"
  fi

  echo "$idx. $url $status_message"

  ts="$(TZ=Europe/Moscow date +'%Y-%m-%d %H:%M:%S')"
  printf ",%s,%s,%s,%s,%s,%s,%s,%s\n" \
    "$(csv_escape "$idx")" "$(csv_escape "$name")" "$(csv_escape "$employer_name")" \
    "$(csv_escape "$url")" "$(csv_escape "$prev_applied_human")" "$(csv_escape "$sent")" \
    "$(csv_escape "$reason")" "$(csv_escape "$ts")" >> "$REPORT_FILE"
done < <(jq -c '.[]' <<< "$SELECTED_ENTRIES_JSON")

echo
if [[ "$any_sent" -eq 1 ]]; then echo "Готово. CSV-отчёт: $REPORT_FILE"
else echo "Заявки не отправлены (всё пропущено/ошибки). CSV-отчёт: $REPORT_FILE"; fi